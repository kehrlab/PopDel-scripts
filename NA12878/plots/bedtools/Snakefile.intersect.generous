configfile: "scripts/bedtools/config.yaml"


##### DO NOT TOUCH THIS! ####
TRUTH=expand("{file}", file=config["fullTruthFile"])
TRUTH_FILTERED=expand("{file}.{L}-{R}{c}", file=config["fullTruthFile"], L=config["left"], R=config["right"], c=config["filterCentromeres"])

OVERLAP=config["overlap"]

POPDELBED=expand("{out}popdel.deletions.bed", out=config["outpath"])
DELLYBED=expand( "{out}delly.deletions.bed",  out=config["outpath"])
LUMPYBED=expand( "{out}lumpy.deletions.bed",  out=config["outpath"])


COUNT=expand("{out}counts.{t}.{L}-{R}{c}.{o}.noBorderCases.tsv", out=config["outpath"], t=config["truthSet"], L=config["left"], R=config["right"], c=config["filterCentromeres"], o=config["overlap"])

##### DO NOT TOUCH THIS! ####

rule all:
   input:
      COUNT

rule vcf2bed_popdel:
   input:
      config["vcfs"]["popdel"]
   output:
      temp(POPDELBED)
   shell:
      "grep -v ^# {input} | grep -v \"^chrUn\" | grep -v \"random\" | grep -v \"chrY\" | sed 's/;/\\t/g' | sed -e 's;SVLEN=-;;g' | awk -v OFS='\\t' '{{print$1,$2,$2+$9}}' | sort -u -k1,1 -k2,2n -k3,3n > {output}"

rule vcf2bed_delly:
   input:
      config["vcfs"]["delly"]
   output:
      temp(DELLYBED)
   shell:
      "grep -v ^# {input} | grep -v \"0/0\" | grep -v \"^chrUn\" | grep -v \"random\" | grep -v \"chrM\" | grep -v \"chrEBV\" | grep -v \"chrY\" | awk -v OFS='\\t' '{{if($5==\"<DEL>\" && $7==\"PASS\"){{print $0}}}}' | sed 's/;/\\t/g' | cut -f 1,2,12 | sed 's/END=//g' | sort -u -k1,1 -k2,2n -k3,3n > {output}"

rule vcf2bed_lumpy:
   input:
      config["vcfs"]["lumpy"]
   output:
      temp(LUMPYBED)
   shell:
      "grep -v ^# {input} | grep -v \"0/0\" | grep -v \"^chrUn\" | grep -v \"random\" | grep -v \"chrM\" | grep -v \"chrEBV\" | grep -v \"chrY\" | awk -v OFS='\\t' '{{if($5==\"<DEL>\"){{print $0}}}}' | sed 's/;/\\t/g' | cut -f 1,2,10 | sed 's/END=//g' | sort -u -k1,1 -k2,2n -k3,3n > {output}"

rule sizeFilterCalls:
   input:
      temp(expand("{out}{{tool}}.deletions.bed", out=config["outpath"]))
   output:
      temp(expand("{out}{{tool}}.deletions.{L}-{R}.bed", out=config["outpath"], L=config["left"], R=config["right"]))
   params:
      getRange=expand("awk -v OFS='\\t' '{{if($3 - $2 >= {L} && $3 - $2 <= {R}){{print $0}}}}'", L=config["left"], R=config["right"])
   shell:
      "{params.getRange} {input} > {output}"

rule sizeFilterTruth:
   input:
      truth=config["fullTruthFile"]
   output:
      temp(expand("{file}.{L}-{R}", L=config["left"], R=config["right"], file=config["fullTruthFile"]))
   params:
      getRange=expand("awk -v OFS='\\t' '{{if($3 - $2 >= {L} && $3 - $2 <= {R}){{print $0}}}}'", L=config["left"], R=config["right"])
   shell:
      "{params.getRange} {input} > {output}"

rule centromereFilterTruth:
   input:
      truth=expand("{file}.{L}-{R}", L=config["left"], R=config["right"], file=config["fullTruthFile"]),
      regions=config["centromereFile"]
   output:
      temp(expand("{file}.{L}-{R}_noCentromeres", L=config["left"], R=config["right"], file=config["fullTruthFile"]))
   shell:
      "bedtools intersect -v -a {input.truth} -b {input.regions} > {output}"

rule centromereFilterCalls:
   input:
      calls=expand("{out}{{tool}}.deletions.{L}-{R}.bed", out=config["outpath"], L=config["left"], R=config["right"]),
      regions=config["centromereFile"]
   output:
      temp(expand("{out}{{tool}}.deletions.{L}-{R}.bed_noCentromeres", out=config["outpath"], t=config["truthSet"], L=config["left"], R=config["right"]))
   shell:
      "bedtools intersect -v -a {input.calls} -b {input.regions} > {output}"

rule get_B: ## True FP
   input:
      calls=expand("{out}{{tool}}.deletions.{L}-{R}.bed{c}", out=config["outpath"], L=config["left"], R=config["right"], c=config["filterCentromeres"]),
      truth=TRUTH
   output:
      temp(expand("{out}intersects/B.{{tool}}.bed", out=config["outpath"], L=config["left"], R=config["right"]))
   params:
      OVERLAP
   shell:
      "bedtools intersect -v -r -f {params} -a {input.calls} -b {input.truth} > {output}"

rule get_A: ## True FN
   input:
      calls=expand("{out}{{tool}}.deletions.bed", out=config["outpath"]),
      truth=TRUTH_FILTERED
   output:
      expand("{out}intersects/A.{{tool}}.bed", out=config["outpath"], L=config["left"], R=config["right"])
   params:
      OVERLAP
   shell:
      "bedtools intersect -v -r -f {params} -a {input.truth} -b {input.calls} > {output}"

rule get_CD:
   input:
      truth=TRUTH_FILTERED,
      calls=expand("{out}{{tool}}.deletions.bed", out=config["outpath"])
   output:
      temp(expand("{out}intersects/CD.{{tool}}.bed", out=config["outpath"]))
   params:
      OVERLAP
   shell:
      "bedtools intersect -wa -u -r -f {params} -a {input.truth} -b {input.calls} > {output}"

rule get_DE:
   input:
      truth=TRUTH,
      calls=expand("{out}{{tool}}.deletions.{L}-{R}.bed_noCentromeres", out=config["outpath"], t=config["truthSet"], L=config["left"], R=config["right"])
   output:
      temp(expand("{out}intersects/DE.{{tool}}.bed", out=config["outpath"]))
   params:
      OVERLAP
   shell:
      "bedtools intersect -wa -u -r -f {params} -a {input.truth} -b {input.calls} > {output}"

rule get_C:
   input:
      a=expand("{out}intersects/CD.{{tool}}.bed", out=config["outpath"]),
      b=expand("{out}intersects/DE.{{tool}}.bed", out=config["outpath"])
   output:
      temp(expand("{out}intersects/C.{{tool}}.bed", out=config["outpath"]))
   params:
      OVERLAP
   shell:
      "bedtools intersect -v -r -f {params} -a {input.a} -b {input.b} > {output}"

rule build_CDE:
   input:
      a=expand("{out}intersects/C.{{tool}}.bed", out=config["outpath"]),
      b=expand("{out}intersects/DE.{{tool}}.bed", out=config["outpath"])
   output:
      temp(expand("{out}intersects/CDE.{{tool}}.bed", out=config["outpath"]))
   params:
      OVERLAP
   shell:
      "cat {input.a} {input.b} | sort -u -k1,1 -k2n,2 -k3n,3 > {output}"

rule get_truePopDelX:
   input:
      first=expand("{out}intersects/CDE.popdel.bed", out=config["outpath"]),
      second=expand("{out}intersects/CDE.{{tool, (delly|lumpy)}}.bed", out=config["outpath"])
   output:
      temp(expand("{out}intersects/true.popdel.{{tool, (delly|lumpy)}}.bed", out=config["outpath"]))
   params:
      OVERLAP
   shell:
      "bedtools intersect -wa -u -r -f {params} -a {input.first} -b {input.second} > {output}"

rule get_c:
   input:
      first=expand("{out}intersects/true.popdel.lumpy.bed", out=config["outpath"]),
      second=expand("{out}intersects/CDE.delly.bed", out=config["outpath"]),
   output:
      temp(expand("{out}intersects/c.popdel.lumpy.bed", out=config["outpath"]))
   params:
      OVERLAP
   shell:
      "bedtools intersect -v -r -f {params} -a {input.first} -b {input.second} > {output}"

rule get_d:
   input:
      first=expand("{out}intersects/true.popdel.delly.bed", out=config["outpath"]),
      second=expand("{out}intersects/CDE.lumpy.bed", out=config["outpath"]),
   output:
      temp(expand("{out}intersects/d.popdel.delly.bed", out=config["outpath"]))
   params:
      OVERLAP
   shell:
      "bedtools intersect -v -r -f {params} -a {input.first} -b {input.second} > {output}"

rule get_a:
   input:
      first=expand("{out}intersects/true.popdel.delly.bed", out=config["outpath"]),
      second=expand("{out}intersects/CDE.lumpy.bed", out=config["outpath"]),
   output:
      temp(expand("{out}intersects/a.popdel.delly.lumpy.bed", out=config["outpath"]))
   params:
      OVERLAP
   shell:
      "bedtools intersect -wa -u -r -f {params} -a {input.first} -b {input.second} > {output}"

rule get_trueDellyLumpy:
   input:
      first=expand("{out}intersects/CDE.delly.bed", out=config["outpath"]),
      second=expand("{out}intersects/CDE.lumpy.bed", out=config["outpath"])
   output:
      temp(expand("{out}intersects/true.delly.lumpy.bed", out=config["outpath"]))
   params:
      OVERLAP
   shell:
      "bedtools intersect -wa -u -r -f {params} -a {input.first} -b {input.second} > {output}"

rule get_g:
   input:
      first=expand("{out}intersects/true.delly.lumpy.bed", out=config["outpath"]),
      second=expand("{out}intersects/CDE.popdel.bed", out=config["outpath"])
   output:
      temp(expand("{out}intersects/g.delly.lumpy.bed", out=config["outpath"]))
   params:
      OVERLAP
   shell:
      "bedtools intersect -v -r -f {params} -a {input.first} -b {input.second} > {output}"

rule get_b:
   input:
      first=expand("{out}intersects/CDE.popdel.bed", out=config["outpath"]),
      second=expand("{out}intersects/CDE.delly.bed", out=config["outpath"]),
      third=expand("{out}intersects/CDE.lumpy.bed", out=config["outpath"])
   output:
      temp(expand("{out}intersects/b.popdel.bed", out=config["outpath"]))
   params:
      OVERLAP
   shell:
      "bedtools intersect -v -r -f {params} -a {input.first} -b {input.second} {input.third} > {output}"

rule get_f:
   input:
      first=expand("{out}intersects/CDE.lumpy.bed", out=config["outpath"]),
      second=expand("{out}intersects/CDE.popdel.bed", out=config["outpath"]),
      third=expand("{out}intersects/CDE.delly.bed", out=config["outpath"])
   output:
      temp(expand("{out}intersects/f.lumpy.bed", out=config["outpath"]))
   params:
      OVERLAP
   shell:
      "bedtools intersect -v -r -f {params} -a {input.first} -b {input.second} {input.third} > {output}"

rule get_e:
   input:
      first=expand("{out}intersects/CDE.delly.bed", out=config["outpath"]),
      second=expand("{out}intersects/CDE.popdel.bed", out=config["outpath"]),
      third=expand("{out}intersects/CDE.lumpy.bed", out=config["outpath"])
   output:
      temp(expand("{out}intersects/e.delly.bed", out=config["outpath"]))
   params:
      OVERLAP
   shell:
      "bedtools intersect -v -r -f {params} -a {input.first} -b {input.second} {input.third} > {output}"

rule get_h:
   input:
      first=TRUTH_FILTERED,
      second=expand("{out}intersects/CDE.popdel.bed", out=config["outpath"]),
      third=expand("{out}intersects/CDE.delly.bed", out=config["outpath"]),
      fourth=expand("{out}intersects/CDE.lumpy.bed", out=config["outpath"])
   output:
      temp(expand("{out}intersects/h.truth.bed", out=config["outpath"]))
   params:
      OVERLAP
   shell:
      "bedtools intersect -v -r -f {params} -a {input.first} -b {input.second} {input.third} {input.fourth} > {output}"

rule get_FPPopDelX:
   input:
      first=expand("{out}intersects/B.popdel.bed", out=config["outpath"]),
      second=expand("{out}intersects/B.{{tool, (delly|lumpy)}}.bed", out=config["outpath"])
   output:
      temp(expand("{out}intersects/fp.popdel.{{tool, (delly|lumpy)}}.bed", out=config["outpath"]))
   params:
      OVERLAP
   shell:
      "bedtools intersect -wa -u -r -f {params} -a {input.first} -b {input.second} > {output}"

rule get_FPDellyLumpy:
   input:
      first=expand("{out}intersects/B.delly.bed", out=config["outpath"]),
      second=expand("{out}intersects/B.lumpy.bed", out=config["outpath"])
   output:
      temp(expand("{out}intersects/fp.delly.lumpy.bed", out=config["outpath"]))
   params:
      OVERLAP
   shell:
      "bedtools intersect -wa -u -r -f {params} -a {input.first} -b {input.second} > {output}"

rule get_i:
   input:
      first=expand("{out}intersects/fp.popdel.delly.bed", out=config["outpath"]),
      second=expand("{out}intersects/B.lumpy.bed", out=config["outpath"])
   output:
      temp(expand("{out}intersects/i.popdel.delly.lumpy.bed", out=config["outpath"]))
   params:
      OVERLAP
   shell:
      "bedtools intersect -wa -u -r -f {params} -a {input.first} -b {input.second} > {output}"

rule get_m:
   input:
      first=expand("{out}intersects/fp.popdel.delly.bed", out=config["outpath"]),
      second=expand("{out}intersects/B.lumpy.bed", out=config["outpath"])
   output:
      temp(expand("{out}intersects/m.popdel.delly.bed", out=config["outpath"]))
   params:
      OVERLAP
   shell:
      "bedtools intersect -v -r -f {params} -a {input.first} -b {input.second} > {output}"

rule get_n:
   input:
      first=expand("{out}intersects/fp.popdel.lumpy.bed", out=config["outpath"]),
      second=expand("{out}intersects/B.delly.bed", out=config["outpath"])
   output:
      temp(expand("{out}intersects/n.popdel.lumpy.bed", out=config["outpath"]))
   params:
      OVERLAP
   shell:
      "bedtools intersect -v -r -f {params} -a {input.first} -b {input.second} > {output}"

rule get_j:
   input:
      first=expand("{out}intersects/B.popdel.bed", out=config["outpath"]),
      second=expand("{out}intersects/B.delly.bed", out=config["outpath"]),
      third=expand("{out}intersects/B.lumpy.bed", out=config["outpath"])
   output:
      temp(expand("{out}intersects/j.popdel.bed", out=config["outpath"]))
   params:
      OVERLAP
   shell:
      "bedtools intersect -v -r -f {params} -a {input.first} -b {input.second} {input.third} > {output}"

rule get_k:
   input:
      first=expand("{out}intersects/B.delly.bed", out=config["outpath"]),
      second=expand("{out}intersects/B.popdel.bed", out=config["outpath"]),
      third=expand("{out}intersects/B.lumpy.bed", out=config["outpath"])
   output:
      temp(expand("{out}intersects/k.delly.bed", out=config["outpath"]))
   params:
      OVERLAP
   shell:
      "bedtools intersect -v -r -f {params} -a {input.first} -b {input.second} {input.third} > {output}"

rule get_l:
   input:
      first=expand("{out}intersects/B.lumpy.bed", out=config["outpath"]),
      second=expand("{out}intersects/B.popdel.bed", out=config["outpath"]),
      third=expand("{out}intersects/B.delly.bed", out=config["outpath"])
   output:
      temp(expand("{out}intersects/l.lumpy.bed", out=config["outpath"]))
   params:
      OVERLAP
   shell:
      "bedtools intersect -v -r -f {params} -a {input.first} -b {input.second} {input.third} > {output}"

rule get_o:
   input:
      first=expand("{out}intersects/fp.delly.lumpy.bed", out=config["outpath"]),
      second=expand("{out}intersects/B.popdel.bed", out=config["outpath"])
   output:
      temp(expand("{out}intersects/o.delly.lumpy.bed", out=config["outpath"]))
   params:
      OVERLAP
   shell:
      "bedtools intersect -v -r -f {params} -a {input.first} -b {input.second} > {output}"

rule getCounts:
   input:
      truth=TRUTH_FILTERED,
      tp_popdel=expand("{out}intersects/CDE.popdel.bed", out=config["outpath"]),
      tp_delly=expand("{out}intersects/CDE.delly.bed", out=config["outpath"]),
      tp_popdel_delly=expand("{out}intersects/d.popdel.delly.bed", out=config["outpath"]),   ## d
      tp_popdel_lumpy=expand("{out}intersects/c.popdel.lumpy.bed", out=config["outpath"]),   ## c
      tp_delly_lumpy=expand("{out}intersects/g.delly.lumpy.bed", out=config["outpath"]),     ## g
      tp_all=expand("{out}intersects/a.popdel.delly.lumpy.bed", out=config["outpath"]), ## a
      tp_popdel_only=expand("{out}intersects/b.popdel.bed", out=config["outpath"]), ## b
      tp_delly_only=expand("{out}intersects/e.delly.bed", out=config["outpath"]),   ## e
      tp_lumpy=expand("{out}intersects/CDE.lumpy.bed", out=config["outpath"]),
      tp_lumpy_only=expand("{out}intersects/f.lumpy.bed", out=config["outpath"]),      ## f
      fn_popdel=expand("{out}intersects/A.popdel.bed", out=config["outpath"]),
      fn_delly=expand("{out}intersects/A.delly.bed", out=config["outpath"]),
      fn_lumpy=expand("{out}intersects/A.lumpy.bed", out=config["outpath"]),
      fn_all=expand("{out}intersects/h.truth.bed", out=config["outpath"]),              ## h
      fp_popdel=expand("{out}intersects/B.popdel.bed", out=config["outpath"]),
      fp_popdel_only=expand("{out}intersects/j.popdel.bed", out=config["outpath"]),      ## j
      fp_delly=expand("{out}intersects/B.delly.bed", out=config["outpath"]),
      fp_delly_only=expand("{out}intersects/k.delly.bed", out=config["outpath"]),        ## k
      fp_lumpy=expand("{out}intersects/B.lumpy.bed", out=config["outpath"]),
      fp_lumpy_only=expand("{out}intersects/l.lumpy.bed", out=config["outpath"]),         ## l
      fp_popdel_delly=expand("{out}intersects/m.popdel.delly.bed", out=config["outpath"]), ## m
      fp_popdel_lumpy=expand("{out}intersects/n.popdel.lumpy.bed", out=config["outpath"]), ## n
      fp_delly_lumpy=expand("{out}intersects/o.delly.lumpy.bed", out=config["outpath"]), ## o
      fp_all=expand("{out}intersects/i.popdel.delly.lumpy.bed", out=config["outpath"]) ## i

   output:
      COUNT
   shell:
      """
      set +o pipefail
      wc -l {input.truth} {input.tp_popdel} {input.fp_popdel} {input.fn_popdel} {input.tp_delly} {input.fp_delly} {input.fn_delly} {input.tp_lumpy} {input.fp_lumpy} {input.fn_lumpy} | head -n10 > {output}
      wc -l {input.tp_popdel_only} {input.tp_delly_only} {input.tp_lumpy_only} {input.tp_popdel_delly} {input.tp_popdel_lumpy} {input.tp_delly_lumpy} {input.tp_all} {input.fn_all} {input.fp_popdel_only} {input.fp_delly_only} {input.fp_lumpy_only} {input.fp_popdel_delly} {input.fp_popdel_lumpy} {input.fp_delly_lumpy} {input.fp_all}| head -n15 >> {output}
      """
          #   sed -i -e \"s;{input.truth};truth;g\" \
          #   -e \"s;{input.popdel};popdel;g\" \
          #   -e \"s;{input.delly};delly;g\" \
          #   -e \"s;{input.lumpy};lumpy;g\" \
          #   -e \"s;{input.tp_popdel};truth_popdel;g\" \
          #   -e \"s;{input.tp_delly};truth_delly;g\" \
          #   -e \"s;{input.tp_lumpy};truth_lumpy;g\" \
          #   -e \"s;{input.popdel_delly};popdel_delly;g\" \
          #   -e \"s;{input.popdel_lumpy};popdel_lumpy;g\" \
          #   -e \"s;{input.delly_lumpy};delly_lumpy;g\" \
          #   -e \"s;{input.tp_popdel_delly};truth_popdel_delly;g\" \
          #   -e \"s;{input.tp_popdel_lumpy};truth_popdel_lumpy;g\" \
          #   -e \"s;{input.tp_delly_lumpy};truth_delly_lumpy;g\" \
          #   -e \"s;{input.popdel_delly_lumpy};popdel_delly_lumpy;g\" \
          #   -e \"s;{input.tp_popdel_delly_lumpy};truth_popdel_delly_lumpy;g\" \
          #   {output}
